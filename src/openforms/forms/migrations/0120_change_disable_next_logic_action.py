# Generated by Django 4.2.27 on 2026-01-07 10:25

import uuid

from django.db import migrations
from django.db.migrations.state import StateApps

from openforms.formio.service import iter_components
from openforms.utils.json_logic import introspect_json_logic
from openforms.variables.service import resolve_key


def rules_contain_disable_next_action(rules):
    for rule in rules:
        for action in rule.actions:
            if action["action"]["type"] == "disable-next":
                return True

    return False


def create_action(step):
    return {
        "action": {"type": "disable-next"},
        "form_step_uuid": str(step.uuid),
        "uuid": str(uuid.uuid4()),
    }


def add_form_step_uuid_to_disable_next_actions(apps: StateApps, _):
    Form = apps.get_model("forms", "Form")
    FormLogic = apps.get_model("forms", "FormLogic")

    forms = Form.objects.prefetch_related(
        "formlogic_set", "formvariable_set", "formstep_set"
    )
    rules_to_update = set()
    for form in forms.iterator(chunk_size=10):
        # We don't care about deleted forms
        if form._is_deleted:
            continue

        # Set of logic rules which contain a "disable next" action.
        logic_rules = {
            rule
            for rule in form.formlogic_set.all()
            for action in rule.actions
            if action["action"]["type"] == "disable-next"
        }
        # Exit early if none of the rules contain a disable action. Deliberately do not
        # check if actions already contain a form step uuid, because it might be present
        # due to historical reasons. We want to override (possibly) outdated form step
        # uuids.
        if not logic_rules:
            continue

        # Add logic rules of this form to overall collection of rules to update.
        rules_to_update.update(logic_rules)

        # Mapping from component to step for quick access
        form_steps = form.formstep_set.select_related("form_definition")
        component_to_step = {
            component["key"]: step
            for step in form_steps.iterator()
            for component in iter_components(
                step.form_definition.configuration,
                recursive=True,
                recurse_into_editgrid=False,
            )
        }
        form_variables = {var.key: var for var in form.formvariable_set.iterator()}

        # Process logic rules
        for rule in logic_rules:
            # Create a set of input variable steps by analyzing the logic trigger.
            input_variable_steps = set()
            for input_var in introspect_json_logic(
                rule.json_logic_trigger
            ).get_input_keys():
                form_variable_key = resolve_key(input_var.key, form_variables)
                if (form_variable := form_variables.get(form_variable_key)) is None:
                    continue

                if form_variable.prefill_plugin:
                    # If the variable has prefill configured -> add the first step.
                    # This is because prefilled data will be available upon submission
                    # creation, so the rule _could_ be triggered on the first step. If
                    # prefill did not succeed, we still need to execute it on step of
                    # the input variable as well, because the user might be asked to
                    # fill in the data manually.
                    input_variable_steps.add(form_steps.first())

                if (step := component_to_step.get(form_variable.key)) is None:
                    # Cannot resolve step -> do nothing (likely because the variable is
                    # user defined).
                    continue

                input_variable_steps.add(step)

            new_actions = []
            rule_contains_disable_next = False
            for action in rule.actions:
                if action["action"]["type"] != "disable-next":
                    # If the action is not of type "disable next", just add it to the
                    # new action list.
                    new_actions.append(action)
                    continue

                if rule_contains_disable_next:
                    # If it already contains a disable next action -> do not add this
                    # one to the list of new actions. Note that this is unlikely, but
                    # will avoid messing up the rule.
                    continue

                rule_contains_disable_next = True
                new_actions.append(action)

                if len(input_variable_steps) == 0:
                    # There are no input variables from the logic trigger, so assign the
                    # first step as a best guess (unless "trigger_from_step" is
                    # defined).
                    step_to_assign = (
                        rule.trigger_from_step
                        if rule.trigger_from_step is not None
                        else form_steps.first()
                    )
                    action["form_step_uuid"] = str(step_to_assign.uuid)
                elif len(input_variable_steps) == 1:
                    # If there is only one step, assign it to the action (unless
                    # "trigger_from_step" is defined).
                    step_to_assign = (
                        rule.trigger_from_step
                        if rule.trigger_from_step is not None
                        else input_variable_steps.pop()
                    )
                    action["form_step_uuid"] = str(step_to_assign.uuid)
                else:
                    # If "trigger_from_step" is defined, ensure we add it, and remove
                    # all other input variable steps that are before it.
                    if rule.trigger_from_step:
                        input_variable_steps.add(rule.trigger_from_step)
                        input_variable_steps = [
                            step
                            for step in input_variable_steps
                            if step.order >= rule.trigger_from_step.order
                        ]

                    # There are multiple steps, so assign the first step to the current
                    # action, and create new actions for the remaining steps
                    input_variable_steps = sorted(
                        input_variable_steps, key=lambda step: step.order
                    )
                    action["form_step_uuid"] = str(input_variable_steps.pop(0).uuid)

                    # Add new actions to the rule
                    new_actions.extend(
                        [create_action(step) for step in input_variable_steps]
                    )

            rule.actions = new_actions

    if rules_to_update:
        FormLogic.objects.bulk_update(rules_to_update, fields=("actions",))


def remove_form_step_uuid_from_disable_next_actions(apps: StateApps, _):
    Form = apps.get_model("forms", "Form")
    FormLogic = apps.get_model("forms", "FormLogic")

    forms = Form.objects.prefetch_related("formlogic_set")
    rules_to_update = set()
    for form in forms.iterator(chunk_size=10):
        # We don't care about deleted forms
        if form._is_deleted:
            continue

        for rule in form.formlogic_set.iterator():
            new_actions = []
            rule_contains_disable_next = False
            for action in rule.actions:
                if action["action"]["type"] != "disable-next":
                    new_actions.append(action)
                    continue

                if rule_contains_disable_next:
                    # If it already contains a disable next action -> do not add this
                    # one to the list of new actions.
                    continue

                rule_contains_disable_next = True
                action["form_step_uuid"] = ""
                new_actions.append(action)
                rules_to_update.add(rule)

            rule.actions = new_actions

    if rules_to_update:
        FormLogic.objects.bulk_update(rules_to_update, fields=("actions",))


class Migration(migrations.Migration):
    dependencies = [
        ("forms", "0119_fix_component_configurations"),
    ]

    operations = [
        migrations.RunPython(
            add_form_step_uuid_to_disable_next_actions,
            remove_form_step_uuid_from_disable_next_actions,
        )
    ]
